\documentclass{article}

\usepackage[utf8]{inputenc}
\usepackage{blindtext}
\usepackage{graphicx}
\usepackage{float} % Elimina la condicion de flotante de las imagenes
\usepackage[english, activeacute]{babel}
\usepackage{amsmath}
\usepackage{etoolbox,fancyhdr,xcolor} % Colores
\usepackage[hidelinks]{hyperref} % Indice dinámico
\usepackage[a4paper]{geometry}
\usepackage{listings} % Para mostrar fragmentos de código.
\usepackage{multicol}

\title{Assignment 1. Hill climbing and simulated annealing }
\author{José Manuel Izquierdo Ramírez}

\newcommand{\headrulecolor}[1]{\patchcmd{\headrule}{\hrule}{\color{#1}\hrule}{}{}}
\newcommand{\footrulecolor}[1]{\patchcmd{\footrule}{\hrule}{\color{#1}\hrule}{}{}}
\pagestyle{fancy}
\fancyhf{}% Clear header/footer
\fancyhead[L]{\textsl{\leftmark}}
\fancyfoot[C]{\thepage}% \fancyfoot[R]{\thepage}
\renewcommand{\headrulewidth}{0.4pt}% Default \headrulewidth is 0.4pt
\renewcommand{\footrulewidth}{0.4pt}% Default \footrulewidth is 0pt
\headrulecolor{cyan!70}% Set header rule colour to 70% red.
\footrulecolor{cyan!70}
\renewcommand{\sectionmark}[1]{\markboth{#1}{}}
\renewcommand{\subsectionmark}[1]{\markright{#1}}

% Multicol
\setlength{\columnseprule}{0.4pt}
\def\columnseprulecolor{\color{cyan!70}}

% Anular el sangrado
\setlength{\parindent}{0cm}



\begin{document}

    \begin{titlepage}
        
        \centering
        {\LARGE\bfseries Assignment 1. Hill climbing and simulated annealing \par}
        \vspace{0,5cm}
        {\itshape\Large Metaheuristics \par}
        \vspace{0,5cm}        
        \vspace{1cm}
        \includegraphics[width=0.6\textwidth]{../media/Logo_UCO.png}\par
        \vspace{3cm}
        {\LARGE\bfseries José Manuel Izquierdo Ramírez \par}

        %{\large \today\par}

    \end{titlepage}
    
    \begin{index}
        \tableofcontents
        \newpage
        \listoffigures
    \end{index}

    \newpage
    
    \section{Exercise 1.}
    \subsection{How does this algorithm behave as we increase the complexity of the problem (number of cities in the TSP)?}

        For this question I have evaluated the algorithm measuring the time and the legnth of the final path, to do this I 
        have done the mean of five iterations for each city using eleven cities between 5 and 150.

        \begin{figure}[H]

            \centering
            \includegraphics[width=0.5\textwidth]{../media/01.TSP-cities-time.png}
            \caption{Time complexity of Hill Climbing}
            \label{Time complexity of Hill Climbing}

        \end{figure}

        From this figure we can say that the complexity of the algorithm increases exponentially as the number of cities increases.

        \begin{figure}[H]

            \centering
            \includegraphics[width=0.5\textwidth]{../media/02.TSP-cities-length.png}
            \caption{Length of final path TSP problem}
            \label{Length of final path TSP problem}

        \end{figure}

        From this figure we can say that obviously the more cities there are the longer the path will be, however it seems that the heuristic 
        are finfing good solutions because the slope does not increase too much.


    \subsection{Do you always get the best solution? Why? What does it depend on?}

        We do not obtain always the best solution, cause of the first randomly generated solution.
        Sometimes the algorithm get trapped on a local maximum and it never reachs the global maximum.


    \subsection{Modify the code to start the search again from another initial solution (Iterated local search). Have you managed to improve? Why?}
        
        It obteins better results but needs more computation time.
        On my case I do it for 1,10 and 100 iterations.

        Doing that It does not matter if the first random solution is not good, because along the execution of the algorithm it can reach a better neighbour.
        For each iteration it compares if the solution given is better than the best solution ever and if it is better it store the value of it.

        \begin{figure}[H]

            \centering
            \includegraphics[width=0.5\textwidth]{../media/03.TSP-iterative.png}
            \caption{Computation time changing the iterations}
            \label{Computation time changing the iterations}

        \end{figure}

    \newpage

    \section{Exercise 2.}

        \subsection{How does this algorithm behave as we increase the problem (number of cities in
    the TSP)?}

        As I have done with the Hill Climbing algorithm I am going to evaluate the algorithm measuring the time and the legnth of the final path, to do this I 
        have done the mean of five iterations for each city using the same cities as the previous exercise.

        \begin{figure}[H]

            \centering
            \includegraphics[width=0.5\textwidth]{../media/01.SimAnnealing-time.png}
            \caption{Time complexity of Simmulated Annealing}
            \label{Time complexity of Simmulated Annealing}

        \end{figure}

        \begin{figure}[H]

            \centering
            \includegraphics[width=0.5\textwidth]{../media/02.SimAnnealing-length.png}
            \caption{Length of final path Simmulated Annealing}
            \label{Length of final path Simmulated Annealing}

        \end{figure}

        \newpage

        \subsection{Do you always get the best solution? Why? What does it depend on?}

            This algorithm not always obtains the best solution, it depends on the initial temperature and the stop condition.

            
        When the temperature is too high we have more probabilities to found the best solution, also we can start near the best solution and get
        far away and do not find it.

        \subsection{Analyze how the behavior of the algorithm varies as we change the stop criteria
    and the initial temperature.}

            I have evaluated the algorithm with 75 cities and 5 iterations for each value of initial temperature and stop condition.

            \begin{figure}[H]

                \centering
                \includegraphics[width=0.5\textwidth]{../media/03.SimAnnealing-Initial-Ta-time-75cities.png}
                \caption{Execution time of Simmulated Annealing changing the initial temperature}
                \label{Execution time of Simmulated Annealing changing the initial temperature}
    
            \end{figure}

            \begin{figure}[H]

                \centering
                \includegraphics[width=0.5\textwidth]{../media/03.SimAnnealing-Initial-Ta-length-75cities.png}
                \caption{Length of the solution of Simmulated Annealing changing the initial temperature}
                \label{Length of the solution of Simmulated Annealing changing the initial temperature}
    
            \end{figure}

            As I had thought when you increase the initial temperature you are very close to the best solution, however 
            the computational time increases.

            \begin{figure}[H]

                \centering
                \includegraphics[width=0.5\textwidth]{../media/03.SimAnnealing-Stop-criteria-time-75cities.png}
                \caption{Execution time of Simmulated Annealing changing the stop condition}
                \label{Execution time of Simmulated Annealing changing the stop condition}
    
            \end{figure}

            \begin{figure}[H]

                \centering
                \includegraphics[width=0.5\textwidth]{../media/03.SimAnnealing-Stop-criteria-length-75cities.png}
                \caption{Length of the solution of Simmulated Annealing changing the stop condition}
                \label{Length of the solution of Simmulated Annealing changing the stop condition temperature}
    
            \end{figure}

            As we can see when the stop condition is too high the algorithm stop to early.


        \subsection{Modify the code to use different cooling functions}
    
            \subsubsection{Logarithmic.}

                \begin{lstlisting}[language=Python]
                    t = (alpha * t)/math.log(1+it)
                \end{lstlisting}

    
            \subsubsection{Geometric.}
            
                \begin{lstlisting}[language=Python]
                    t = math.pow(alpha,it)*t 
                \end{lstlisting}

        \subsection{How do these functions affect the final results? Why? Help yourself by representing the values of these functions. Look for new features and compare them to the old ones.}

            Changing the cooling function I have evaluate the algorithm using a range between 5 and 150 cities and 5 iterations for each one.

            \begin{figure}[H]

                \centering
                \includegraphics[width=0.5\textwidth]{../media/03.SimAnnealing-Geometric-time.png}
                \caption{Time complexity using Geometric cooling function}
                \label{Time complexity using Geometric cooling function}
    
            \end{figure}

            \begin{figure}[H]

                \centering
                \includegraphics[width=0.5\textwidth]{../media/03.SimAnnealing-Geometric-length.png}
                \caption{Length of the solution using Geometric cooling function}
                \label{Length of the solution using Geometric cooling function}
    
            \end{figure}

            \begin{figure}[H]

                \centering
                \includegraphics[width=0.5\textwidth]{../media/03.SimAnnealing-Logarithmic-time.png}
                \caption{Time complexity using Logarithmic cooling function}
                \label{Time complexity using Logarithmic cooling function}
    
            \end{figure}

            \begin{figure}[H]

                \centering
                \includegraphics[width=0.5\textwidth]{../media/03.SimAnnealing-Logarithmic-length.png}
                \caption{Length of the solution using Logarithmic cooling function}
                \label{Length of the solution using Logarithmic cooling function}
    
            \end{figure}
    
        \subsection{How would you improve the algorithm? For example, reheating so often. Modify
    the code with this and any other improvement you guess is appropriate. Analyze
    the results.}

            To improve that algorithm I would take some time evaluating all the possibles combinations of parameters to found the best one.

\end{document}